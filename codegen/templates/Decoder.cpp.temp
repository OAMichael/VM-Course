#include "Decoder.h"


namespace {

/* [[[cog
import cog
from yaml import load, dump
try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

cog.msg("generate get and make part funcs")
data = load(open(isa_file, 'r'), Loader=Loader)

fields = data['fields'].values() # ['opcode'] # ['location']['bits']

cppTypes = {'opcode': 'InstructionType', 'r1': 'RegisterType', 'r2': 'RegisterType', 'intrCode': 'IntrinsicType', 'imm': 'ImmediateIndex'}

for field in fields:
    typeName = cppTypes[field['name']]
    cog.outl(f"inline VM::{typeName} get_{field['name']}(const EncodedInstruction instr) {{")
    bits = field['location']['bits']
    cog.outl(f"\treturn static_cast<VM::{typeName}>(getPartialBitsShifted<{bits['msb']}, {bits['lsb']}>(instr));")
    cog.outl("}")

for field in fields:
    typeName = cppTypes[field['name']]
    cog.outl(f"inline uint32_t make_{field['name']}(const uint32_t val) {{")
    bits = field['location']['bits']
    cog.outl(f"\treturn makePartialBits<{bits['msb']}, {bits['lsb']}>(instr);")
    cog.outl("}")

]]] */

// [[[end]]]

}

namespace VM {

void Decoder::decodeInstruction(const EncodedInstruction &encInstr, DecodedInstruction& decInstr) const {
    const InstructionType opcode = getOpcode(encInstr);

    switch(opcode) {
        /* [[[cog
        types = data['types']

        instr_refer_to_types = {}
        for instr in data['instructions'].values():
            instr_refer_to_types.setdefault(instr['type'], []).append(instr)

        for type, params in types.items():
            for instr in instr_refer_to_types[type]:
                cog.outl(f'case InstructionType::{instr["name"].upper()}:')
            cog.outl('{')
            for part in params:
                cog.outl(f'\tdecInstr.{part} = get_{part}(encInstr)')
            cog.outl('\tbreak;')
            cog.outl('}')
        
        cog.outl('default: {')
        cog.outl('\tdecInstr.opcode = InstructionType::INSTRUCTION_INVALID;')
        cog.outl('\tbreak;')
        cog.outl('}')
        ]]] */
        
        // [[[end]]]
    }
}


void Decoder::encodeInstruction(const DecodedInstruction& decInstr, EncodedInstruction& encInstr) const {

    switch(decInstr.opcode) {
        /* [[[cog
        for type, params in types.items():
            for instr in instr_refer_to_types[type]:
                cog.outl(f'case InstructionType::{instr["name"].upper()}:')
            cog.outl('{')
            param_size = len(params)
            for idx, part in enumerate(params):
                cog.outl('{}make_{}(decInstr.{}) {}'.format(
                    "\tencInstr = " if idx == 0 else "\t\t\t\t", 
                    part, 
                    part,
                    "|" if idx != param_size - 1 else ";"))
            cog.outl('\tbreak;')
            cog.outl('}')
        
        cog.outl('default: {')
        cog.outl('\tencInstr = make_opcode(InstructionType::INSTRUCTION_INVALID);')
        cog.outl('\tbreak;')
        cog.outl('}')
        ]]] */
        
        // [[[end]]]
    }
}


}   // VM
